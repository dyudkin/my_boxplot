

# R Functions -------------------------------------------------------------
# rm(list=ls())
# source("/Users/DanielYudkin/Dropbox/R/R Functions.R")
# Read and write files.

# load the scripts
require("ggplot2")
require("dplyr")
require("broom")
require("tibble")
require("sjPlot")
require("sjstats")
require("clean")

require("tidyr")
#require("corrplot")
require("psych")
require("car")
require("lme4")
require("tidyverse")
require("readxl")
require("magrittr")
require("tools")
require("lavaan")
require("ggrepel")

#install.packages("mice")

require("lmerTest")
require(RColorBrewer)


# RIO IMPORT
summarize <- dplyr::summarize
select <- dplyr::select
# Read.csv

# my.read <- function(x){
#                 read.csv(x, stringsAsFactors = F)
#
# }

my.read <- function(x) {
        if (file_ext(x) == "csv") {
                read.csv(x, stringsAsFactors = F)
        }
        else
                (read_excel(x))
}


# Write csv.
my.write <- function(x, y, row.names = F) {
        write.csv(x, y, row.names = row.names)
        
}

# Save plot and table.
my.save.graph <-
        function(summary.table.name,
                 summary.filename,
                 graph.name,
                 graph.filename) {
                my.write(summary.table.name, summary.filename)
                
                pdf(graph.filename, width = 12, height = 8)
                print(graph.name)
                dev.off()
                
        }

my.save.graph.2 <-
        function(outputvariable,
                 table.filename,
                 graph.filename) {
                my.write(outputvariable[[1]], table.filename)
                pdf(graph.filename, width = 12, height = 8)
                print(outputvariable[[2]])
                dev.off()
                
        }


# Mean and sd
my.stats <- function(x) {
        mean = mean(x, na.rm = T)
        sd = sd(x, na.rm = T)
        n = sum(!is.na(x))
        print <-
                paste0(paste0("Mean: ", mean, "; "),
                  paste0("SD: ", sd, "; "),
                  paste0("N: ", n, "; "))
        return(print)
        
}

my.see.last.columns <- function(data, n = 30) {
        head(data[, (ncol(data) - n):ncol(data)], n)
}

my.outersect <- function(x, y) {
        list(setdiff(x, y),
               setdiff(y, x))
}

my.table <- function(...){
        x <- table(..., useNA = "always")
        return(x)
        
}

# Graphs ------------------------------------------------------------------

my.blue <- "#1675B5"
my.red <- "#b52616"
my.colors <- c("#1675B5", "#b52616")
my.bright.colors <- c("#0011ff", "#ff0000")





my.graph.settings <- function(x = 0, size = 12) {
        my.graph.settings <-
                theme_bw(base_size = size) +
                theme(
                        panel.border = element_blank(),
                        axis.line = element_line(colour = "black"),
                        panel.grid.major.x = element_blank(),
                        panel.grid.minor.x = element_blank(),
                        panel.grid.major.y = element_blank(),
                        panel.grid.minor.y = element_blank(),
                        panel.background = element_rect(fill = "transparent", colour = NA),
                        plot.background = element_rect(fill = "transparent", colour = NA),
                        legend.key = element_rect(fill = "transparent", colour = NA),
                        legend.background = element_rect(fill = "transparent", colour = NA),
                        axis.text =  element_text(colour = "black"),
                        axis.title = element_text(face = "bold")
                )
        if (x > 0) {
                my.graph.settings <-
                        my.graph.settings + theme(axis.text.x = element_text(angle = x, hjust = 1))
        }
        return(my.graph.settings)
}



# SummarySE ---------------------------------------------------------------

my.summary <-
        function(dataset,
                 x,
                 y,
                 xlab = x,
                 ylab = y,
                 width = .1,
                 height = .1,
                 ...) {
                quo_x <- rlang::sym(x)
                quo_y <- rlang::sym(y)
                condensed <- dataset %>% group_by(!!quo_x) %>%
                        summarise(
                                sd = sd(!!quo_y, na.rm = T),
                                se = sd / sqrt(length(!!quo_y)),
                                mean = mean(!!quo_y, na.rm = T),
                                n = sum(!is.na(!!quo_y))
                        ) %>%
                        mutate(
                                min = mean - qt(.975, n - 1) * se,
                                lower = mean - se,
                                upper = mean + se,
                                max = mean + qt(.975, n - 1) * se
                        )
                return(condensed)
        }




my.grouped.summary <-
        function(dataset,
                 x,
                 y,
                 group,
                 xlab = x,
                 ylab = y,
                 width = .1,
                 height = .1,
                 ...) {
                quo_x <- rlang::sym(x)
                quo_y <- rlang::sym(y)
                quo_group <- sym(group)
                condensed <- dataset %>% group_by(!!quo_group,!!quo_x) %>%
                        summarise(
                                sd = sd(!!quo_y, na.rm = T),
                                SE = sd / sqrt(length(!!quo_y)),
                                mean = mean(!!quo_y, na.rm = T),
                                length = length(!!quo_y),
                                n = n()
                        ) %>%
                        mutate(
                                min = mean - qt(.975, length - 1) * SE,
                                lower = mean - SE,
                                upper = mean + SE,
                                max = mean + qt(.975, length - 1) * SE
                        )
                return(condensed)
        }


# Transpose ---------------------------------------------------------------

my.transpose <- function(data.frame, row.name) {
        # first remember the names
        n <- data.frame[[row.name]]
        # transpose all but the first column (name)
        data.frame <- as.data.frame(t(data.frame[, ]))
        colnames(data.frame) <- n
        return(data.frame)
}

my.center <- function(x) {
        x <- x - mean(x, na.rm = T)
        x
}


my.scale <- function(x) {
        x <- x - mean(x, na.rm = T)
        x <- x / sd(x, na.rm = T)
        x
}

my.reorder <- function(dataframe, factor, orderVar) {
        quo_factor <- sym(factor)
        quo_orderVar <- sym(orderVar)
        dataframe <- dataframe %>%
                arrange(!!quo_orderVar) %>%
                mutate(factor = factor(!!quo_factor,!!quo_factor))
        dataframe

}



my.table.output <- function(table, rhs, lhs) {
        row <- table[table$lhs == lhs & table$rhs == rhs, ]
        beta <- round(row[3], 3)
        SE <- round(row[4], 3)
        p <- round(row[5], 3)
        output <-
                ifelse(
                        p >= .001,
                        paste0("_B_", " = ", beta, ", _SE_", " = ", SE, ", _p_ = ", p),
                        ifelse(
                                p < .001,
                                paste0("_B_", " = ", beta, ", _SE_", " = ", SE, ", _p_ < ", .001),
                                NA
                        )
                )
        return(output)
}



# Regression Output -------------------------------------------------------
my.lm <- function(data,
                          predictor,
                          dv,
                          controls,
                          row.name = predictor,
                          add.controls = NULL,
                          rm.controls = NULL,
                          caption = NULL,
                  type = "summary") {
        model <-
                my.return.model.lm(data,
                                   predictor,
                                   dv,
                                   controls,
                                   add.controls,
                                   rm.controls)
        if (Console == T) {
                if (type == "summary"){
                        print(summary(model))
                        print(my.lm.output((model), row.name))
                }
                else if (type == "anova"){
                        print(anova(model))
                        print(my.lm.output((model), row.name))
                }
        }
        if (PDF == T) {
                print_lm(model, predictor, dv, caption)
        }
        invisible(model)
        
}
my.regress.lm <- my.lm


my.lmer <- function(data,
                            predictor,
                            dv,
                            controls,
                            rdm.effect,
                            row.name = predictor,
                            add.controls = NULL,
                            rm.controls = NULL,
                    type = "summary",
                            caption = NULL) {
        model <-
                my.return.model.lmer(data,
                                   predictor,
                                   dv,
                                   controls,
                                   rdm.effect,
                                   add.controls,
                                   rm.controls)
        if (Console == T) {
                if (type == "summary"){
                        print(summary(model))
                        print(my.lmer.output((model), row.name))
                }
                else if (type == "anova"){
                        print(anova(model))
                        print(my.lmer.output((model), row.name))
                }
        }
        if (PDF == T) {
                print_lmer(model, predictor, dv, timepoint, caption)
        }
        invisible(model)
}


my.return.model.lm <- function(data, predictor, dv, controls, add.controls = NULL, rm.controls = NULL) {
        controls <- controls[!controls %in% rm.controls]
        controls <- paste(c(controls, add.controls), collapse = " + ")
        predictors <- paste(predictor, controls, sep = " + ")
        formula <- paste(dv, predictors, sep = " ~ ")
        model <- lm(formula, data = data)
        return(model)
}

my.return.model.lmer <- function(data, predictor, dv, controls, rdm.effect, add.controls = NULL, rm.controls = NULL) {
        controls <- controls[!controls %in% rm.controls]
        controls <- paste(c(controls, add.controls), collapse = " + ")
        rdm.effect <- paste0("(1|", rdm.effect, ")")
        predictors <-
                paste(predictor, controls, rdm.effect, sep = " + ")
        formula <- paste(dv, predictors, sep = " ~ ")
        model <- lmer(formula, data = data)
        return(model)
}




my.lm.output <- function(model, variable) {
        coefs <- filter(tidy(model), term == variable)
        beta <- sprintf("%.2f", round(coefs$estimate, 2))
        SE <- sprintf("%.2f", round(coefs$std.error, 2))
        t <- sprintf("%.2f", round(coefs$statistic, 2))
        df <- glance(model)$df.residual %>% round()
        p <- round(coefs$p.value, 3)
        output2 <-
                ifelse(
                        p >= .001,
                        paste0(
                                "_B_",
                                " = ",
                                beta,
                                ", _SE_",
                                " = ",
                                SE,
                                ", _t_(",
                                df,
                                ") = ",
                                t,
                                ", _p_ = ",
                                p
                        ),
                        ifelse(
                                p < .001,
                                paste0(
                                        "_B_",
                                        " = ",
                                        beta,
                                        ", _SE_",
                                        " = ",
                                        SE,
                                        ", _t_(",
                                        df,
                                        ") = ",
                                        t,
                                        ", _p_ < ",
                                        .001
                                ),
                                NA
                        )
                )
        output <- as.vector(output2)
        print(summary(model))
        return(output)
}

my.lmer.output <- function(model, variable) {
        coefs <- summary(model)$coefficients[variable, ]
        beta <- sprintf("%.2f", round(coefs[1], 2))
        SE <- sprintf("%.2f", round(coefs[2], 2))
        t <- sprintf("%.2f", round(coefs[4], 2))
        df <- round(coefs[3], 0)
        p <- round(coefs[5], 3)
        output <-
                ifelse(
                        p >= .001,
                        paste0(
                                "_B_",
                                " = ",
                                beta,
                                ", _SE_",
                                " = ",
                                SE,
                                ", _t_(",
                                df,
                                ") = ",
                                t,
                                ", _p_ = ",
                                p
                        ),
                        ifelse(
                                p < .001,
                                paste0(
                                        "_B_",
                                        " = ",
                                        beta,
                                        ", _SE_",
                                        " = ",
                                        SE,
                                        ", _t_(",
                                        df,
                                        ") = ",
                                        t,
                                        ", _p_ < ",
                                        .001
                                ),
                                NA
                        )
                )
        output <- as.vector(output)
        return(output)
}


my.anova <- function(model){
        anova1 <- anova(model)
        numerator <- anova1$Df[1]
        denomonator <- tail(anova1$Df, n = 1)
        f.value = anova1$`F value`[1] %>% round(., 2)
        p.value = anova1$`Pr(>F)`[1] %>% round(., 3)
        output <- paste0("_F_", 
                         "(",
                         numerator, 
                         ", ",
                         denomonator,
                         "), = ",
                         f.value,
                         ", _p_ = ",
                         p.value)
        print(list(anova1, output))
}







# Residuals ---------------------------------------------------------------



my.lm.resid <- function(data, DV, controls) {
        controls <- paste(controls, sep = " + ")
        formula <- paste(DV, controls, sep = " ~ ")
        DV.resid <- paste(DV, ".resid", sep = "")
        data <- augment(lm(formula, data = data), data)
        data <-
                data %>% rename_(.dots = setNames(list(".resid"), DV.resid))
        return(data)
}


my.lmer.resid <- function(data, predictor, DV, controls) {
        controls <- paste(controls, sep = " + ")
        formula <- paste(variable, predictors, sep = " ~ ")
        new <- paste(variable, ".resid", sep = "")
        var <- ".resid"
        data <- augment(lm(f, data = data), data)
        data <- data %>% rename_(.dots = setNames(list(var), new))
        return(data)
}






#  Mediation --------------------------------------------------------------
my.compile.lavaan <- function(data, a, b, c, controls = NULL, rm.controls = NULL, title = NULL){
        controls <- controls[!controls %in% rm.controls]
        equation1 <- paste0(b, " ~ a*", a, " + ", paste(controls, collapse = " + "), "\n")
        equation2 <- paste0(c, " ~ b*", b, " + ", "c*", a, "+", paste(controls, collapse = " + "), "\n")
        equation3 <- "
        IndirectTotal := a*b
        DirectEffect := c
        TotalEffect := c + a*b
        "
        model <- paste0(equation1, equation2, equation3)
        model <- cfa(model, data = data, missing = "fiml", std.lv = T)
        
        if (Console == T) {
                output <- summary(model, ci = T)
                table <- standardizedsolution(model)
                indirect.effect <- my.print.indirect.effect(table)
                print(indirect.effect)
        }
        if (PDF == T) {
                print_lavaan(model, title)
        }

        invisible(model)
        
}



# Notes:
# a1: a to b
# a2: a to c
# b1: b to c
# b2: b do d
# c: c to d 

my.compile.lavaan.complex <- function(data, a, b, c, d, controls = NULL, rm.controls = NULL, title = NULL){
        controls <- controls[!controls %in% rm.controls]
        equation1 <- paste0(b, " ~ a1*", a, " + ", paste(controls, collapse = " + "), "\n")
        equation2 <- paste0(c, " ~ a2*", a, " + ", "b1*", b, "+", paste(controls, collapse = " + "), "\n")
        equation3 <- paste0(d, " ~ b2*", b, " + ", "c*", c, "+", "d*", a, "+", paste(controls, collapse = " + "), "\n")
        equation4 <- "
        IndirectEffect1 := a1*b1
        IndirectEffect2 := a1*b2
        IndirectEffect3 := a2*c
        IndirectEffect4 := b1*c
        IndirectTotal := a1*b1*c
        DirectEffect := d
        TotalEffect := a1*b1 + a1*b2 + a2*c + b1*c + a1*b1*c + d
        "
        model <- paste0(equation1, equation2, equation3, equation4)
        model <- cfa(model, data = data, missing = "fiml", std.lv = T)
        

        if (Console == T) {
                output <- summary(model, ci = T)
                table <- standardizedsolution(model)
                indirect.effect <- my.print.indirect.effect(table)
                print(indirect.effect)
                
        }
        if (PDF == T) {
                print_lavaan(model, title)
        }
        
        invisible(model)
}


my.print.indirect.effect <- function(x){
        beta <- x[x[["lhs"]]=="IndirectTotal",]$est.std %>% round(3)
        SE <- x[x[["lhs"]]=="IndirectTotal",]$se %>% round(3)
        p <- x[x[["lhs"]]=="IndirectTotal",]$pvalue %>% round(3)
        lower <- x[x[["lhs"]]=="IndirectTotal",]$ci.lower %>% round(3)
        upper <- x[x[["lhs"]]=="IndirectTotal",]$ci.upper %>% round(3)
        output <-
                ifelse(
                        p >= .001,
                        paste0(
                                "_B_",
                                " = ",
                                beta,
                                ", _SE_",
                                " = ",
                                SE,
                                ", _p_ = ",
                                p,
                                ", ",
                                "CI_95_[",
                                lower,
                                ", ",
                                upper,
                                "]"
                        ),
                        ifelse(
                                p < .001,
                                paste0(
                                        "_B_",
                                        " = ",
                                        beta,
                                        ", _SE_",
                                        " = ",
                                        SE,
                                        ", _p_ < ",
                                        .001,
                                        ", ",
                                        "CI_95_[",
                                        lower,
                                        ", ",
                                        upper,
                                        "]"
                                ),
                                NA
                        )
                )
        return(output)
}








# T-tests -----------------------------------------------------------------
# Single-sample t-test, compare to 0.
my.single.t <- function(x) {
        t <- t.test(x, mu = 0)
        sd <- sd(x, na.rm = T)
        d <- t$estimate / sd
        print(t)
        print(paste0("SD: ", sd))
        print(paste0("D: ", d))
}

# Paired Sample t-test
my.paired.t <- function(x, y) {
        t <- t.test(x, y, paired = T)
        sd <- sd(x - y, na.rm = T)
        d <- t$estimate / sd
        mean1 <- mean(x, na.rm = T)
        mean2 <- mean(y, na.rm = T)
        print(t)
        print(paste0("Mean 1: ", mean1, ";  Mean 2: ", mean2))
        print(paste0("SD: ", sd))
        print(paste0("D: ", d))
}


# Independent samples t-test
my.two.sample.t <- function(x, y) {
        t <- t.test(x ~ y, var.equal = T)
        sd <- sd(x, na.rm = T)
        d <- (t$estimate[1] - t$estimate[2]) / sd
        print(describeBy(x, group = y)[1])
        print(describeBy(x, group = y)[2])
        print(paste0("D: ", d))
        print(t)
        
}


# Correlation -------------------------------------------------------------
# Correlation Table, output to current wd
my.correlation.table <-
        function(x,
                 filename,
                 pointsize = 20,
                 r = FALSE,
                 height = 2000,
                 width = 2000,
                 cutoff = .1) {
                Correlations <- corr.test(x, adjust = "none")
                Correlations$p[Correlations$p > cutoff] <- NaN
                if (r == FALSE) {
                        png(
                                file = filename,
                                height = height,
                                width = width,
                                pointsize = pointsize
                        )
                        corrplot(
                                Correlations$r,
                                type = "lower",
                                method = "circle",
                                p.mat = Correlations$p,
                                sig.level = .0,
                                insig = "p-value",
                                na.label = "  ",
                                tl.cex = 1,
                                tl.srt = 45,
                                tl.col = "black"
                        )
                        dev.off()
                }
                if (r == TRUE) {
                        Correlations$r[is.nan(Correlations$p)] <- NaN
                        png(
                                file = filename,
                                height = height,
                                width = width,
                                pointsize = pointsize
                        )
                        corrplot(
                                Correlations$r,
                                type = "lower",
                                method = "circle",
                                sig.level = cutoff,
                                na.label = "  ",
                                tl.cex = 1,
                                tl.srt = 45,
                                tl.col = "black",
                                addCoef.col = "black",
                        )
                        dev.off()
                }
        }


my.correlation.output <- function(dataframe, variable1, variable2) {
        cor <- cor.test(dataframe[[variable1]], dataframe[[variable2]])
        asterisk <- ifelse(cor$p.value > .1, "",
                           ifelse(
                                   between(cor$p.value, .05, .1),
                                   "*",
                                   ifelse(
                                           between(cor$p.value, .01, .05),
                                           "**",
                                           ifelse(cor$p.value < .01, "***", "")
                                   )
                           ))
        output <- paste0(round(cor$estimate, 2), asterisk)
        print(cor$estimate)
        print(cor$p.value)
        return(output)
        
        
}

# Compare Correlation Coefficients
cor.diff.test = function(x1, x2, y1, y2, method = "pearson") {
        cor1 = cor.test(x1, x2, method = method)
        cor2 = cor.test(y1, y2, method = method)
        
        r1 = cor1$estimate
        r2 = cor2$estimate
        n1 = sum(complete.cases(x1, x2))
        n2 = sum(complete.cases(y1, y2))
        fisher = ((0.5 * log((1 + r1) / (1 - r1))) - (0.5 * log((1 + r2) /
                                                                        (1 - r2)))) / ((1 / (n1 - 3)) + (1 / (n2 - 3))) ^ 0.5
        
        p.value = (2 * (1 - pnorm(abs(fisher))))
        
        result = list(
                "cor1" = list(
                        "estimate" = as.numeric(cor1$estimate),
                        "p.value" = cor1$p.value,
                        "n" = n1
                ),
                "cor2" = list(
                        "estimate" = as.numeric(cor2$estimate),
                        "p.value" = cor2$p.value,
                        "n" = n2
                ),
                "p.value.twosided" = as.numeric(p.value),
                "p.value.onesided" = as.numeric(p.value) / 2
        )
        cat(
                paste(
                        sep = "",
                        "cor1: r=",
                        format(result$cor1$estimate, digits = 3),
                        ", p=",
                        format(result$cor1$p.value, digits = 3),
                        ", n=",
                        result$cor1$n,
                        "\n",
                        "cor2: r=",
                        format(result$cor2$estimate, digits = 3),
                        ", p=",
                        format(result$cor2$p.value, digits = 3),
                        ", n=",
                        result$cor2$n,
                        "\n",
                        "diffence: p(one-sided)=",
                        format(result$p.value.onesided, digits = 3),
                        ", p(two-sided)=",
                        format(result$p.value.twosided, digits = 3),
                        "\n"
                )
        )
        return(result)
        
}


# Barplots ----------------------------------------------------------------
my.barplot <-
        function(dataset,
                 x,
                 y,
                 xlab = x,
                 ylab = y,
                 round = 2,
                 ordered = F) {
                quo_x <- rlang::sym(x)
                quo_y <- rlang::sym(y)
                summary <- my.summary(dataset, x, y)
                summary$mean.R <- round(summary$mean, round)
                summary <- summary[complete.cases(summary), ]
                if(ordered == T){
                        summary <- summary %>% arrange(mean)
                        summary[[x]] <- factor(summary[[x]], levels = summary[[x]])
                }
                print(summary)
                print(quo_x)
                limits <- aes(ymax = summary$max, ymin = summary$min)
                dodge <- position_dodge()
                graph <- ggplot(summary, aes_string(x = x, y = "mean", group = x)) +
                        geom_bar(stat = 'identity',
                                 position = dodge,
                                 fill = "steelblue") +
                        geom_errorbar(limits, position = dodge, width = 0.1) +
                        # geom_label(aes_string(label = paste0( "n =",  "n")),
                        #            fill = "white",
                        #            position = dodge) +
                        my.graph.settings(0) +
                        ylab(ylab) +
                        xlab(xlab) +
                        coord_cartesian(ylim = c((
                                min(summary$lower) - 5 * mean(summary$se)
                        ), (
                                max(summary$upper) + 5 * mean(summary$se)
                        ))) +
                        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                        scale_y_continuous(expand = c(0, 0))
                measurevar <- y
                groupvars  <- c(x)
                f <- paste(measurevar, groupvars, sep = " ~ ")
                lm <- anova(lm(f, data = dataset))
                print(lm)
                return(graph)
        }



#2 x 2 Bar Graph
my.grouped.barplot <-
        function(dataset,
                 x,
                 y,
                 group,
                 xlab = x,
                 ylab = y,
                 fill.label = group,
                 round = 2) {
                quo_x <- rlang::sym(x)
                quo_y <- rlang::sym(y)
                quo_group <- sym(group)
                summary <- dataset %>% group_by(!!quo_group,!!quo_x) %>%
                        summarise(
                                mean = mean(!!quo_y, na.rm = T),
                                sd = sd(!!quo_y, na.rm = T),
                                n = n()
                        )
                summary$se <- summary$sd / sqrt(summary$n)
                summary$upper <-
                        summary$mean + 1.96 * summary$se
                summary$lower <- summary$mean - 1.96 * summary$se
                
                summary <- summary[complete.cases(summary), ]
                summary$mean.R <- paste0(round(summary$mean, round))
                print(quo_x)
                limits <- aes(ymax = upper, ymin = lower)
                dodge <- position_dodge(width = .9)
                graph <-
                        ggplot(summary,
                               aes_string(
                                       x = x,
                                       y = "mean",
                                       fill = group,
                                       group = group
                               )) +
                        geom_bar(stat = 'identity', position = dodge) +
                        geom_errorbar(limits, position = dodge, width = .2) +
                        #geom_label(aes_string(label = "mean.R"), fill = "white", position=dodge) +
                        my.graph.settings(0) +
                        ylab(ylab) +
                        xlab(xlab) +
                        labs(fill = fill.label) +
                        scale_fill_brewer(palette = "Set1") +
                        coord_cartesian(ylim = c((
                                min(summary$lower) - 5 * mean(summary$se)
                        ), (
                                max(summary$upper) + 5 * mean(summary$se)
                        ))) +
                        theme(axis.text.x = element_text(angle = 45, hjust = 1))
                measurevar <- y
                groupvars  <- c(x, group)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- anova(lm(f, data = dataset))
                print(lm)
                return(list(summary, graph))
        }


# Boxplots -----------------------------------------------
my.boxplot <-
        function(data,
                 x,
                 y,
                 xlab = x,
                 ylab = y,
                 width = .1,
                 fill = "red",
                 alpha = .8,
                 height = .1,
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                condensed <- data %>% group_by(!!quo_x) %>%
                        summarise(
                                SE = sd(!!quo_y, na.rm = T) / sqrt(length(!!quo_y)),
                                mean = mean(!!quo_y, na.rm = T),
                                length = length(!!quo_y)
                        ) %>%
                        mutate(
                                min = mean - qt(.975, length - 1) * SE,
                                max = mean + qt(.975, length - 1) * SE,
                                lower = mean - SE,
                                upper = mean + SE
                        )
                graph <- ggplot(condensed, aes_string(x = x, y = "mean")) +
                        geom_boxplot(
                                aes_string(
                                        ymin = "min",
                                        lower = "lower",
                                        middle = "mean",
                                        upper = "upper",
                                        ymax = "max"
                                ),
                                width = width,
                                stat = "identity",
                                fill = fill,
                                alpha = alpha
                        ) +
                        # geom_jitter(data = data,
                        #             aes_string(x = x, y = y),
                        #             position=position_jitter(width=width, height=height),
                        #             alpha = .2) +
                        ylab(ylab) +
                        xlab(xlab) +
                        my.graph.settings(0) +
                        #scale_fill_manual(values = fill) +
                        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                        coord_cartesian(...)
                
                measurevar <- y
                predictor  <- x
                f <- paste(measurevar, predictor, sep = " ~ ")
                lm <- anova(lm(f, data = data))
                print(lm)
                return(graph)
        }


#2 x 2 Box Plot
my.grouped.boxplot <-
        function(dataset,
                 x,
                 y,
                 group,
                 xlab = x,
                 ylab = y,
                 width = .1,
                 height = .1,
                 ...) {
                quo_x <- rlang::sym(x)
                quo_y <- rlang::sym(y)
                quo_group <- sym(group)
                condensed <- dataset %>% group_by(!!quo_group,!!quo_x) %>%
                        summarise(
                                SE = sd(!!quo_y, na.rm = T) / sqrt(length(!!quo_y)),
                                mean = mean(!!quo_y, na.rm = T),
                                length = length(!!quo_y)
                        ) %>%
                        mutate(
                                min = mean - qt(.975, length - 1) * SE,
                                lower = mean - SE,
                                upper = mean + SE,
                                max = mean + qt(.975, length - 1) * SE
                        )
                graph <- ggplot(condensed, aes_string(x = x, y = "mean")) +
                        geom_boxplot(
                                data = condensed,
                                aes_string(
                                        x = x,
                                        group = group,
                                        fill = group,
                                        ymin = "min",
                                        lower = "lower",
                                        middle = "mean",
                                        upper = "upper",
                                        ymax = "max",
                                        width = .7
                                ),
                                stat = "identity"
                        ) +
                        # geom_point(data = dataset,
                        #            aes_string(x = x, fill = group, color = group, y = y),
                        #            position=position_jitterdodge(dodge.width = .7, jitter.width = width, jitter.height = height),
                        #            alpha = .2) +
                        ylab(ylab) +
                        xlab(xlab) +
                        labs(color = group) +
                        # scale_fill_brewer(palette="Set1") +
                        # scale_color_brewer(palette="Set1") +
                        my.graph.settings(0)
                #scale_y_continuous(limits = c(60, 90))
                measurevar <- y
                groupvars  <- c(x, group)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- anova(lm(f, data = dataset))
                print(lm)
                return(graph)
        }

#2 x 2 x 2 Box Plot
my.2x2x2.boxplot <-
        function(dataset,
                 x,
                 y,
                 group,
                 panels,
                 xlab = x,
                 ylab = y,
                 width = .1,
                 height = .1) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                quo_group <- sym(group)
                quo_panels <- sym(panels)
                condensed <-
                        dataset %>% group_by(!!quo_group,!!quo_x,!!quo_panels) %>%
                        summarise(
                                SE = sd(!!quo_y, na.rm = T) / sqrt(length(!!quo_y)),
                                mean = mean(!!quo_y, na.rm = T),
                                length = length(!!quo_y)
                        ) %>%
                        mutate(
                                min = mean - qt(.975, length - 1) * SE,
                                lower = mean - SE,
                                upper = mean + SE,
                                max = mean + qt(.975, length - 1) * SE
                        )
                graph <- ggplot(condensed, aes_string(x = x, y = "mean")) +
                        geom_boxplot(
                                data = condensed,
                                aes_string(
                                        x = x,
                                        group = group,
                                        fill = group,
                                        ymin = "min",
                                        lower = "lower",
                                        middle = "mean",
                                        upper = "upper",
                                        ymax = "max",
                                        width = .7
                                ),
                                stat = "identity",
                                alpha = .8
                        ) +
                        facet_grid(reformulate(panels)) +
                        scale_fill_brewer(palette = "Set1") +
                        ylab(ylab) +
                        xlab(xlab) +
                        labs(color = group) +
                        my.graph.settings(0)
                measurevar <- y
                groupvars  <- c(x, group, panels)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- anova(lm(f, data = dataset))
                print(list(lm, condensed))
                return(graph)
        }



# Violin ------------------------------------------------------------------


my.violin <- function(data, x, y, ...) {
        quo_x <- sym(x)
        quo_y <- sym(y)
        summary <- my.summary(data, x, y)
        graph <-
                ggplot(data = data, aes_string(
                        x = x,
                        y = y,
                        fill = x
                )) +
                scale_fill_viridis_d(option = "D") +
                geom_violin(
                        alpha = 0.4,
                        position = position_dodge(width = .75),
                        size = 1,
                        color = "black"
                ) +
                geom_jitter(
                        shape = 21,
                        size = 2,
                        color = "black",
                        alpha = 1,
                        width = .15,
                        height = .1
                ) +
                stat_summary(
                        fun.y = mean,
                        geom = "point",
                        size = 4,
                        color = "red",
                        show.legend = F
                ) +
                geom_errorbar(
                        data = summary,
                        aes_string(
                                x = x,
                                y = "mean",
                                ymax = "upper",
                                ymin = "lower"
                        ),
                        position = position_dodge(),
                        width = 0.1
                ) +
                guides(fill = F) +
                coord_cartesian(...) +
                my.graph.settings()
        measurevar <- y
        groupvars  <- x
        f <- paste(measurevar, groupvars, sep = " ~ ")
        anova <- anova(lm(f, data = data))
        p_value <- paste("p =", round(anova[[5]][1], 3))
        #graph <- graph + annotate("text", x = 2.5, y = -.2, label = p_value)
        print(anova)
        graph
}




my.grouped.violin <- function(data, variable) {
        quo_variable <- rlang::sym(variable)
        summary <- ApData %>% group_by(Condition) %>%
                summarise(
                        mean = mean(!!quo_variable, na.rm = T),
                        sd = sd(!!quo_variable, na.rm = T),
                        n = n()
                )
        summary$se <- summary$sd / sqrt(summary$n)
        summary$upper <-
                summary$mean + 1.96 * summary$se
        summary$lower <- summary$mean - 1.96 * summary$se
        
        graph <-
                ggplot(data = ApData,
                       aes_string(
                               x = "Condition",
                               y = variable,
                               fill = "Condition"
                       )) +
                scale_fill_viridis_d(option = "D") +
                geom_violin(
                        alpha = 0.4,
                        position = position_dodge(width = .75),
                        size = 1,
                        color = "black"
                ) +
                geom_jitter(
                        shape = 21,
                        size = 2,
                        color = "black",
                        alpha = 1,
                        width = .15,
                        height = .1
                ) +
                stat_summary(
                        fun.y = mean,
                        geom = "point",
                        size = 4,
                        color = "red",
                        show.legend = F
                ) +
                geom_errorbar(
                        data = summary,
                        aes_string(
                                x = "Condition",
                                y = "mean",
                                ymax = "upper",
                                ymin = "lower"
                        ),
                        position = position_dodge(),
                        width = 0.1
                ) +
                my.graph.settings()
        measurevar <- variable
        groupvars  <- "Condition"
        f <- paste(measurevar, groupvars, sep = " ~ ")
        anova <- anova(lm(f, data = ApData))
        p_value <- paste("p =", round(anova[[5]][1], 3))
        graph <-
                graph + annotate("text",
                                 x = 2.5,
                                 y = -.2,
                                 label = p_value)
        graph
}






# Line Graphs -------------------------------------------------------------
# Line Graph
my.linegraph <- function(dataset,
                         x,
                         y,
                         xlab = x,
                         ylab = y) {
        quo_x <- rlang::sym(x)
        quo_y <- rlang::sym(y)
        summary <- dataset %>% group_by(!!quo_x) %>%
                summarise(
                        mean = mean(!!quo_y, na.rm = T),
                        sd = sd(!!quo_y, na.rm = T),
                        n = n()
                )
        summary$se <- summary$sd / sqrt(summary$n)
        summary <- summary[complete.cases(summary), ]
        print(summary)
        print(quo_x)
        graph <- ggplot(summary, aes_string(x = x, y = "mean")) +
                geom_point(stat = 'identity', size = 3) +
                geom_line(lwd = 1) +
                my.graph.settings(0) +
                ylab(ylab) +
                xlab(xlab) +
                theme(axis.text.x = element_text(angle = 45, hjust = 1))
        # measurevar <- y
        # groupvars  <- c(x)
        # f <- paste(measurevar, sep=" ~ ")
        # lm <- anova(lm(f, data=dataset))
        # print(lm)
        return(graph)
}

require(RColorBrewer)



# Grouped Line Graph
my.grouped.linegraph <-
        function(dataset,
                 x,
                 y,
                 group,
                 xlab = x,
                 ylab = y) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                quo_group <- sym(group)
                summary <- dataset %>% group_by(!!quo_group,!!quo_x) %>%
                        summarise(
                                mean = mean(!!quo_y, na.rm = T),
                                sd = sd(!!quo_y, na.rm = T),
                                n = n()
                        )
                summary <- summary[complete.cases(summary), ]
                print(summary)
                print(quo_x)
                graph <-
                        ggplot(summary,
                               aes_string(
                                       x = x,
                                       y = "mean",
                                       color = group,
                                       group = group
                               )) +
                        geom_point(stat = 'identity', size = 3) +
                        geom_line(lwd = 1) +
                        my.graph.settings(0) +
                        ylab(ylab) +
                        xlab(xlab) +
                        labs(color = group) +
                        scale_fill_brewer(palette = "Set1") +
                        scale_color_brewer(palette = "Set1") +
                        theme(axis.text.x = element_text(angle = 45, hjust = 1))
                measurevar <- y
                groupvars  <- c(x, group)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- anova(lm(f, data = dataset))
                print(lm)
                return(graph)
        }




# Scatterplots ------------------------------------------------------------
my.scatterplot <-
        function(data,
                 x,
                 y,
                 jittersize = 0,
                 alpha = .2,
                 xlab = x,
                 ylab = y,
                 family = "gaussian",
                 se = F,
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                graph <- ggplot(data = data, aes_string(x = x, y = y)) +
                        geom_jitter(
                                width = jittersize,
                                height = jittersize,
                                alpha = alpha,
                                size = 2,
                                show.legend = FALSE,
                                fullrange = TRUE
                        ) +
                        scale_color_manual(values = my.bright.colors) +
                        geom_smooth(
                                method = "glm",
                                method.args = list(family = family),
                                se = se,
                        ) +
                        my.graph.settings(45) +
                        ylab(ylab) +
                        xlab(xlab) +
                        coord_cartesian(...)
                measurevar <- y
                predictor  <- c(x)
                f <- paste(measurevar, predictor, sep = " ~ ")
                lm <- summary(lm(f, data = data))
                graph <-
                        graph + annotate(
                                "label",
                                x = mean(data[[x]], na.rm = T),
                                y = mean(data[[y]], na.rm = T),
                                label = round(lm$coefficients[8], 10)
                        )
                print(lm)
                return(graph)
        }




my.grouped.scatterplot <-
        function(data,
                 x,
                 y,
                 group,
                 color.lab = group,
                 jittersize = .2,
                 alpha = .2,
                 xlab = x,
                 ylab = y,
                 family = "gaussian",
                 SE = FALSE,
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                quo_group <- sym(group)
                graph <-
                        ggplot(data = data, aes_string(
                                x = x,
                                y = y,
                                color = group
                        )) +
                        # geom_jitter(
                        #         width = jittersize,
                        #         height = jittersize,
                        #         alpha = alpha,
                        #         size = 2,
                        #         show.legend = FALSE
                        # ) +
                        geom_smooth(
                                method = "glm",
                                method.args = list(family = family),
                                se = SE,
                                fullrange = TRUE,
                                fill = "grey80",
                                alpha = .2
                        ) +
                        my.graph.settings(0) +
                        ylab(ylab) +
                        xlab(xlab) +
                        scale_color_manual(values = c(brewer.pal(n = 9, name = "Set1"), "black")) +
                        #scale_color_brewer(palette = "Set1") +
                        #scale_color_viridis_d(option = "D") +
                        theme(legend.key = element_blank()) +
                        guides(color = guide_legend(override.aes = list(fill = NA)),
                               size = F) +
                        labs(color = color.lab) +
                        coord_cartesian(...)
                measurevar <- y
                groupvars  <- c(x, group)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- summary(lm(f, data = data))
                print(lm)
                return(graph)
        }




my.grouped.binomial.scatterplot <-
        function(data,
                 x,
                 y,
                 group,
                 jittersize = .2,
                 alpha = .2,
                 xlab = x,
                 ylab = y,
                 family = "gaussian",
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                quo_group <- sym(group)
                graph <-
                        ggplot(data = data, aes_string(
                                x = x,
                                y = y,
                                color = group
                        )) +
                        geom_jitter(
                                width = jittersize,
                                height = jittersize,
                                alpha = alpha,
                                size = 2,
                                show.legend = FALSE
                        ) +
                        geom_smooth(
                                method = "glm",
                                method.args = list(family = family),
                                se = FALSE,
                                fullrange = TRUE
                        ) +
                        my.graph.settings(0) +
                        ylab(ylab) +
                        xlab(xlab) +
                        labs(color = group) +
                        coord_cartesian(...)
                measurevar <- y
                groupvars  <- c(x, group)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- summary(lm(f, data = data))
                print(lm)
                return(graph)
        }


# 2 x 2 Scatterplot
# Scatterplot plus 2-way regression line
my.2x2.scatterplot <-
        function(data,
                 x,
                 y,
                 group1,
                 group2,
                 jittersize = .2,
                 alpha = .2) {
                graph <-
                        ggplot(data = data, aes_string(
                                x = x,
                                y = y,
                                color = interaction(group1, group2)
                        )) +
                        geom_jitter(
                                width = jittersize,
                                height = jittersize,
                                alpha = alpha,
                                size = 2
                        ) +
                        geom_smooth(
                                method = "loess",
                                se = FALSE,
                                show.legend = FALSE,
                                fullrange = TRUE
                        ) +
                        my.graph.settings(0) +
                        labs(y = y,
                             x = x,
                             color = "Status")
                lm <-
                        summary(lm(data[[y]] ~ data[[x]] * data[[group1]] * data[[group2]], data = data))
                output <- list("lm" = lm, "graph" = graph)
                return(output)
        }

my.binomial.scatterplot <- function(data, x, y, group) {
        graph <- ggplot(data = data, aes_string(
                x = x,
                y = y,
                color = group
        )) +
                geom_jitter(
                        height = .00,
                        width = .3,
                        alpha = 4 / 10,
                        size = count
                ) +
                scale_color_manual(values = c("#1675B5", "#b52616")) +
                geom_smooth(
                        method = "glm",
                        method.args = list(family = "binomial"),
                        se = FALSE,
                        fullrange = TRUE
                ) +
                theme(
                        panel.grid.major.y = element_line(color = "grey90"),
                        panel.grid.major.x = element_blank(),
                        panel.grid.minor = element_blank(),
                        panel.border = element_blank(),
                        panel.background = element_rect(fill = "transparent", colour = NA),
                        plot.background = element_rect(fill = "transparent", colour = NA),
                        legend.background = element_rect(fill = "transparent", colour = NA),
                        legend.key = element_rect(fill = "transparent", colour = NA)
                ) +
                theme(
                        axis.line.x = element_line(color = "black", size = .5),
                        axis.line.y = element_line(color = "black", size = .5)
                ) +
                theme(axis.title = element_text(face = "bold")) +
                theme(legend.title = element_text(face = "bold")) +
                labs(y = y,
                     x = x,
                     color = group)
        measurevar <- y
        groupvars  <- c(x, group)
        f <-
                paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
        lm <-
                summary(glm(f, family = binomial(link = logit), data = data))
        print(lm)
        return(graph)
}

# Count plots --------------------------------------------------------------
my.countplot <-
        function(data,
                 x,
                 y,
                 alpha = .2,
                 round = 1,
                 xlab = x,
                 ylab = y,
                 family = "gaussian",
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                data <-
                        data %>% mutate(Ry = round((!!quo_y) / round) * round)
                graph <- ggplot(data = data, aes_string(x = x, y = "Ry")) +
                        geom_count(show.legend = FALSE,
                                   color = "darkblue",
                                   alpha = .8) +
                        scale_color_manual(values = my.bright.colors) +
                        geom_smooth(
                                method = "glm",
                                method.args = list(family = family),
                                se = T,
                                fullrange = F,
                                color = "#FC4E07",
                                fill = "#FC4E07"
                        ) +
                        my.graph.settings(0) +
                        ylab(ylab) +
                        xlab(xlab) +
                        coord_cartesian(...) +
                        theme(axis.text = element_blank())
                measurevar <- y
                predictor  <- c(x)
                f <- paste(measurevar, predictor, sep = " ~ ")
                lm <- summary(lm(f, data = data))
                print(lm)
                return(graph)
        }

my.grouped.countplot <-
        function(data,
                 x,
                 y,
                 group,
                 round = 1,
                 xlab = x,
                 ylab = y,
                 family = "gaussian",
                 alpha = .2,
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                quo_group <- sym(group)
                data <-
                        data %>% mutate(Ry = round((!!quo_y) / round) * round)
                graph <-
                        ggplot(data = data, aes_string(
                                x = x,
                                y = "Ry",
                                color = group
                        )) +
                        geom_count(show.legend = FALSE,  alpha = alpha) +
                        geom_smooth(
                                method = "glm",
                                method.args = list(family = family),
                                se = TRUE,
                                fullrange = TRUE
                        ) +
                        my.graph.settings(0) +
                        ylab(ylab) +
                        xlab(xlab) +
                        labs(color = group) +
                        coord_cartesian(...)
                measurevar <- y
                groupvars  <- c(x, group)
                f <-
                        paste(measurevar, paste(groupvars, collapse = " * "), sep = " ~ ")
                lm <- summary(lm(f, data = data))
                print(lm)
                return(graph)
        }


my.overlap <- function(data, x, y) {
        table <- table(is.na(data[x]), is.na(data[y]))
        table
        
        
        
}



my.marginal.countplot <-
        function(data,
                 x,
                 y,
                 alpha = .2,
                 round = 1,
                 xlab = x,
                 ylab = y,
                 family = "gaussian",
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                data <-
                        data %>% mutate(Ry = round((!!quo_y) / round) * round)
                graph <- ggplot(data = data, aes_string(x = x, y = "Ry")) +
                        geom_count(show.legend = FALSE,
                                   color = "darkblue",
                                   alpha = .8) +
                        scale_color_manual(values = my.bright.colors) +
                        geom_smooth(
                                method = "glm",
                                method.args = list(family = family),
                                se = T,
                                fullrange = F,
                                color = "#FC4E07",
                                fill = "#FC4E07"
                        ) +
                        theme_light() +
                        ylab(ylab) +
                        xlab(xlab) +
                        coord_cartesian(...) +
                        theme(axis.text = element_blank())
                pmain <- graph
                darkblue <- "darkblue"
                xdens <- axis_canvas(pmain, axis = "x") +
                        geom_density(
                                data = data,
                                aes_string(x = quo_x, fill = 3),
                                alpha = 0.7,
                                size = 0.2
                        )
                ydens <- axis_canvas(pmain, axis = "y", coord_flip = TRUE) +
                        geom_density(
                                data = data,
                                aes_string(x = quo_y, fill = 3),
                                alpha = 0.7,
                                size = 0.2
                        ) +
                        coord_flip()
                p1 <-
                        insert_xaxis_grob(pmain, xdens, grid::unit(.2, "null"), position = "top")
                p2 <-
                        insert_yaxis_grob(p1, ydens, grid::unit(.2, "null"), position = "right")
                p3 <- ggdraw(p2)
                measurevar <- y
                predictor  <- c(x)
                f <- paste(measurevar, predictor, sep = " ~ ")
                lm <- summary(lm(f, data = data))
                print(lm)
                return(p3)
        }




# Histogram ---------------------------------------------------------------
my.histogram <-
        function(data,
                 variable,
                 bins = NULL,
                 percent = FALSE) {
                if (percent == FALSE) {
                        graph <-
                                ggplot(data, aes_string(x = variable)) + geom_histogram(bins = bins) +
                                theme_bw()
                        print(graph)
                }
                else {
                        ggplot(data, aes_string(x = variable)) +
                                geom_bar(aes(y = ..prop.., stat = "count")) +
                                geom_text(
                                        aes(
                                                label = scales::percent(..prop..),
                                                y = ..prop..
                                        ),
                                        stat = "count",
                                        vjust = -.5,
                                        size = 2
                                ) +
                                scale_y_continuous(labels = scales::percent) +
                                labs(y = "Proportion")
                }
        }



my.grouped.histogram <-
        function(data,
                 variable,
                 group,
                 bins = NULL,
                 percent = FALSE) {
                if (percent == FALSE) {
                        graph <-
                                ggplot(data, aes_string(x = variable)) + 
                                geom_histogram(bins = bins) +
                                facet_grid(reformulate(group)) + 
                                theme_bw()
                        print(graph)
                }
                else {
                        ggplot(data, aes_string(x = variable,  group = group)) +
                                geom_bar(aes(y = ..prop.., stat = "count")) +
                                facet_grid(reformulate(group)) +
                                # geom_text(
                                #         aes(
                                #                 label = scales::percent(..prop..),
                                #                 y = ..prop..
                                #         ),
                                #         stat = "count",
                                #         vjust = -.5,
                                #         size = 2
                                # ) +
                                scale_y_continuous(labels = scales::percent) +
                                labs(y = "Proportion")
                }
        }

# Create a residual variable
my.residual <- function(data, variable, ..., family = "gaussian") {
        predictors <- paste(..., sep = " + ")
        f <- paste(variable, predictors, sep = " ~ ")
        new <- paste(variable, ".resid", sep = "")
        var <- ".resid"
        data <- augment(glm(f, family = family, data = data), data)
        data <- data %>% rename_(.dots = setNames(list(var), new))
        drop <-
                c(".fitted",
                  ".se.fit",
                  ".hat",
                  ".sigma",
                  ".cooksd",
                  ".std.resid")
        data <- data %>% select(-one_of(drop))
        return(data)
}

my.multilevel.residual <- function(data, variable, subjectID, ...) {
        subject <- paste0("(1|", subjectID, ")")
        predictors <- paste(..., subject, sep = " + ")
        f <- paste(variable, predictors, sep = " ~ ")
        new <- paste(variable, ".resid", sep = "")
        var <- ".resid"
        data <- augment(lmer(f, data = data), data)
        data <- data %>% rename_(.dots = setNames(list(var), new))
        drop <-
                c(".fitted",
                  ".se.fit",
                  ".hat",
                  ".sigma",
                  ".cooksd",
                  ".std.resid")
        data <- data %>% select(-one_of(drop))
        return(data)
}




# Check Crosstabs (NA) ----------------------------------------------------

my.missing.data <- function(data, string) {
        try <- strsplit(string, "\\+|~")
        try <- try[[1]]
        try <- gsub("\\s+", "" , try)
        matrix <- select(data, try)
        mice:::md.pattern(matrix)
}


# my.missing.data.model <- function(model) {
#         model.frame <- model.frame(model)
#         names <- names(model.frame)
#         df <- df %>% select(names)
#         mice:::md.pattern(df)
# }

my.missing.data.model <- function(model) {
        mice:::md.pattern(model.frame(model))
}

## EXAMPLE my.crosstab(ImmediateFollowup, "TE ~ MoneyFree + EducationC + AgeC + IncomeC + GenderFemale + GenderMale")


# Make class lmer ---------------------------------------------------------

my.make.class.lmer <- function(x) {
        class(x) <- "lmerMod"
}


my.split <- function(x) {
        median <- (max(x, na.rm = T) - min(x, na.rm = T)) / 2
        newvar <- ifelse(x < median, 0, ifelse(x > median, 1, NA))
        return(newvar)
}




# Multiple Imputation -----------------------------------------------------
my.select <- function(string) {
        # Get each variable name individually
        try <- strsplit(string, "\\+|~|\\(1\\||\\)\\|\\)|, data = ")
        try <- try[[1]]
        try <- gsub("\\s+", "" , try)
        try <- gsub("\\)", "" , try)
        try <- try[try != ""]
        data <- tail(try, 1)
        variables <- head(try, c(length(try) - 1))
        data.frame <- eval(sym(data))
        data.frame <- data.frame %>% select(variables)
        data.frame
}



 my.imputation <- function(model, data.frame, use = NA) {
        require(mice) # You will need to install this package if you don't have it already
        names <- names(model.frame(model))
        data.frame <- data.frame %>% select(names)
        
        init <-
                mice(data.frame, maxit = 0) # Initialize the imputation
        meth <-  init$method
        predM <-  init$predictorMatrix
        
        # This if/then statement allows you to specify with variables you want to impute. Default is all;
        # But specific vars can be input like so: use = c("var1", "var2")
        if (is.na(use)) {
                meth <- meth
        } else{
                meth[use] <-  "pmm"
        }
        
        imputed <-
                mice(
                        data.frame,
                        method = meth,
                        predictorMatrix = predM,
                        m = 20
                        ) # Perform the multiple imputation
        
        formula <- paste0(as.character(formula(model))[2], as.character(formula(model))[1], as.character(formula(model))[3])
        # Now run the regression equation on the multiply imputed data
        modelFit1 <- with(imputed, lm(formula = eval(parse(text = formula))))

        # Get the summary of the regression output and print it.
        summary(pool(modelFit1))

}

 citation("mice")




# Countplot Plus Boxplot ------------------------------------------------------------


my.boxplot.countplot <-
        function(data,
                 x,
                 y,
                 xlab = x,
                 ylab = y,
                 width = .8,
                 fill = "red",
                 alpha = .8,
                 height = .1,
                 ...) {
                quo_x <- sym(x)
                quo_y <- sym(y)
                data.count <- data %>%
                        group_by(!!quo_x,!!quo_y) %>%
                        summarise(n = n()) %>%
                        na.omit() %>%
                        mutate(freq = n / sum(n))
                #return(print(data.count, n = 100))
                size_range <- c(min(data.count$freq), max(data.count$freq))
                condensed <- my.summary(data, x, y)
                graph <-
                        ggplot(condensed, aes_string(
                                x = x,
                                y = "mean",
                                fill = x
                        )) +
                        geom_boxplot(
                                aes_string(
                                        ymin = "min",
                                        lower = "lower",
                                        middle = "mean",
                                        upper = "upper",
                                        ymax = "max"
                                ),
                                width = width,
                                stat = "identity",
                                alpha = alpha
                        ) +
                        geom_point(
                                data = data.count,
                                aes_string(
                                        x = x,
                                        y = y,
                                        size = "freq"
                                ),
                                pch = 21,
                                color = "black",
                                fill = "gray88",
                                alpha = .3
                        ) +
                        scale_size_continuous(
                                labels = scales::percent_format(accuracy = 1),
                                name = "Proportion",
                                limits = size_range,
                                range = c(0, 10)
                        ) +
                        scale_fill_viridis_d(option = "D") +
                        ylab(ylab) +
                        xlab(xlab) +
                        guides(fill = F) +
                        my.graph.settings(0) +
                        coord_cartesian(...)
                return(graph)
        }


 

# Print Regression Tables -------------------------------------------------

 
print_lm <-
         function(themodel, 
                  predictor,
                  dv,
                  caption
         ) {
                 if (is.null(caption)){
                         caption <- paste0("Predictor: ", predictor, "; Dependent Variable: ", dv)
                         if (!is.null(timepoint)){
                                 caption <- paste0(caption, "; Timepoint: ", timepoint)
                         }
                 } else {
                         caption <- caption
                 }
                 
                 df <- themodel %>% summary %>% coefficients %>% tail(-1)
                 confint <- confint(themodel) %>% tail(-1)
                 #std.beta <- std_beta(themodel)[,1:2]
                 order <- order(row.names(df))
                 df <- merge(df, confint, by = "row.names") %>%
                         #merge(std.beta, by.x = "Row.names", by.y = "term")%>%
                         arrange(order)
                 df$df <- (themodel$df.residual)
                 
                 
                 dv <- colnames(model.frame(themodel))[1]
                 
                 df <- df %>%
                         rename("p" = "Pr(>|t|)")
                 
                 df$pval = format(round(df$p, digits = 3), nsmall = 3) # round p-values into new variable
                 df$pstring = as.character(df$pval) # convert this variable intro new string variable
                 df$pmaterial = df$pstring
                 
                 
                 df$pstring[df$p < 0.1 &
                                    df$p >= 0.05] <-
                         paste(df$pmaterial[df$p < 0.1 &
                                                    df$p >= 0.05], "(ref:cross)", sep = "")
                 df$pstring[df$p < 0.05 &
                                    df$p >= 0.01] <-
                         paste(df$pmaterial[df$p < 0.05 &
                                                    df$p >= 0.01], "(ref:ast)", sep = "")
                 df$pstring[df$p < 0.01 &
                                    df$p >= 0.001] <-
                         paste(df$pmaterial[df$p < 0.01 &
                                                    df$p >= 0.001], "(ref:ast)", "(ref:ast)", sep = "")
                 df$pstring[df$p < .001] <-
                         paste("< ",
                               "0.001",
                               "(ref:ast)",
                               "(ref:ast)",
                               "(ref:ast)",
                               sep = "")
                 
                 df$pstring <-
                         gsub("0\\.", "\\.", df$pstring)  # add for removing the zero in front of the p values
                 
                 df <- df %>% select(-c(p, pval, pmaterial))
                 
                 
                 df$rhs <- df %>% rownames()
                 rownames(df) <- c()
                 df <- df %>% rename(
                         "b" = "Estimate"
                         ,
                         "SE" = "Std. Error"
                         ,
                         "df" = "df"
                         ,
                         "t" = "t value"
                         ,
                         "(ref:cilower)" = "2.5 %"
                         ,
                         "(ref:ciupper)" = "97.5 %"
                         ,
                         "predictor" = "Row.names"
                         ,
                         "p" = "pstring"
                         #, "b" = "std.estimate"
                 )
                 
                 df <-
                         df %>% select(predictor,
                                       b,
                                       SE,
                                       "(ref:cilower)",
                                       "(ref:ciupper)",
                                       t,
                                       df,
                                       p)
                 
                 return(
                         apa_table(
                                 df,
                                 align = c("l", "r", "r", "r", "r", "r", "r", "S[table-format = <0.3]","r"),
                                 caption = caption,
                                 note = paste(
                                         "(ref:ast)(ref:ast)(ref:ast)(ref:italp) < .001, 
                                                                        (ref:ast)(ref:ast)(ref:italp) < .01, 
                                                                        (ref:ast)(ref:italp) < .05, 
                                                                        (ref:cross)(ref:italp) <.10",
                                         sep = " "
                                 ),
                                 placement = "h",
                                 longtable = TRUE,
                                 escape = T
                         )
                 )
                 
         }
 
 
 
 
 print_lmer <- 
         function(themodel, 
                  Predictor,
                  DV,
                  timepoint,
                  caption
                  ) {
                 if (is.null(caption)){
                         caption <- paste0("Predictor: ", Predictor, "; Dependent Variable: ", DV)
                         if (!is.null(timepoint)){
                                 caption <- paste0(caption, "; Timepoint: ", timepoint)
                         }
                 } else {
                         caption <- caption
                         }
                 
                 df <- themodel %>% summary %>% coefficients %>% tail(-1)
                 confint <- confint(themodel) %>% tail(-3)
                 #std.beta <- std_beta(themodel)[,1:2]
                 order <- order(row.names(df))
                 df <- merge(df, confint, by = "row.names") %>%
                         #merge(std.beta, by.x = "Row.names", by.y = "term")%>%
                         arrange(order)
                 DV <- colnames(model.frame(themodel))[1]
                 
                 df <- df %>%
                         rename("p" = "Pr(>|t|)")
                 
                 df$pval = format(round(df$p, digits = 3), nsmall = 3) # round p-values into new variable
                 df$pstring = as.character(df$pval) # convert this variable intro new string variable
                 df$pmaterial = df$pstring
                 
                 
                 df$pstring[df$p < 0.1 &
                                    df$p >= 0.05] <-
                         paste(df$pmaterial[df$p < 0.1 &
                                                    df$p >= 0.05], "(ref:cross)", sep = "")
                 df$pstring[df$p < 0.05 &
                                    df$p >= 0.01] <-
                         paste(df$pmaterial[df$p < 0.05 &
                                                    df$p >= 0.01], "(ref:ast)", sep = "")
                 df$pstring[df$p < 0.01 &
                                    df$p >= 0.001] <-
                         paste(df$pmaterial[df$p < 0.01 &
                                                    df$p >= 0.001], "(ref:ast)", "(ref:ast)", sep = "")
                 df$pstring[df$p < .001] <-
                         paste("< ",
                               "0.001",
                               "(ref:ast)",
                               "(ref:ast)",
                               "(ref:ast)",
                               sep = "")
                 
                 df$pstring <-
                         gsub("0\\.", "\\.", df$pstring)  # add for removing the zero in front of the p values
                 
                 df <- df %>% select(-c(p, pval, pmaterial))
                 
                 try <- df
                 
                 df <- try
                 
                 df$rhs <- df %>% rownames()
                 rownames(df) <- c()
                 df <- df %>% rename(
                         "b" = "Estimate"
                         ,
                         "SE" = "Std. Error"
                         ,
                         "df" = "df"
                         ,
                         "t" = "t value"
                         ,
                         "(ref:cilower)" = "2.5 %"
                         ,
                         "(ref:ciupper)" = "97.5 %"
                         ,
                         "Predictor" = "Row.names"
                         ,
                         "p" = "pstring"
                         #, "b" = "std.estimate"
                 )
                 
                 df <-
                         df %>% select(Predictor,
                                       b,
                                       SE,
                                       "(ref:cilower)",
                                       "(ref:ciupper)",
                                       t,
                                       df,
                                       p)
                 return(
                         apa_table(
                                 df,
                                 align = c("l", "r", "r", "r", "r", "r", "r", "S[table-format = <0.3]"),
                                 caption = caption,
                                 note = paste(
                                         "(ref:ast)(ref:ast)(ref:ast)(ref:italp) < .001, 
                                                              (ref:ast)(ref:ast)(ref:italp) < .01, 
                                                              (ref:ast)(ref:italp) < .05, 
                                                              (ref:cross)(ref:italp) <.10",
                                         sep = " "
                                 ),
                                 placement = "h",
                                 longtable = TRUE,
                                 escape = T
                         )
                 )
         }
 
 

 print_lavaan <-
         function(themodel,
                  thecaption = "Enter a caption.",
                  thenotes = "",
                  namedv = "",
                  exclude = c(0)) {
                 aa <- standardizedsolution(themodel) %>% data.frame()
                 
                 aa$pstring = format(round(aa$p, digits = 3), nsmall = 3) %>% as.character()
                 aa <-
                         aa %>% mutate(
                                 pstring = case_when(
                                         between(pvalue, .05, .1) ~ paste(pstring, "(ref:cross)", sep = ""),
                                         between(pvalue, .01, .05) ~ paste(pstring, "(ref:ast)", sep =
                                                                                   ""),
                                         between(pvalue, .001, .01) ~ paste(pstring, "(ref:ast)", "(ref:ast)", sep =
                                                                                    ""),
                                         pvalue < .001 ~ paste(
                                                 "< ",
                                                 "0.001",
                                                 "(ref:ast)",
                                                 "(ref:ast)",
                                                 "(ref:ast)",
                                                 sep = ""
                                         ),
                                         pvalue >= .1 ~ pstring
                                 )
                         )
                 aa$pstring[is.na(aa$z)] <- NA
                 aa <-
                         aa[, c("lhs",
                                "op",
                                "rhs",
                                "est.std",
                                "se",
                                "ci.lower",
                                "ci.upper",
                                "z",
                                "pstring")]
                 
                 aa$pstring <-
                         gsub("0\\.", "\\.", aa$pstring)  # add for removing the zero in front of the p values
                 
                 names(aa)[names(aa) == "est.std"] <- "B"
                 names(aa)[names(aa) == "lhs"] <- "Criterion"
                 names(aa)[names(aa) == "ci.lower"] <- "(ref:cilower)"
                 names(aa)[names(aa) == "ci.upper"] <- "(ref:ciupper)"
                 names(aa)[names(aa) == "rhs"] <- "Predictor"
                 names(aa)[names(aa) == "pstring"] <- "p"
                 names(aa)[names(aa) == "std.all"] <- "(ref:beta)"
                 names(aa)[names(aa) == "se"] <- "SE"
                 
                 aa = aa[(aa$op == "~" | aa$op == ":="), ]
                 
                 aa$op[aa$op == "~"] = "\U2190"
                 aa$Predictor[aa$op == ":="] = ""
                 aa$op[aa$op == ":="] = "on"
                 
                 names(aa)[names(aa) == "op"] <- ""
                 aa$Predictor[aa$Predictor == ""] <- "Moral Expansion"
                 
                 #aa <- data.frame(aa)
                 return(
                         apa_table(
                                 aa,
                                 align = c(
                                         "c",
                                         "l",
                                         "l",
                                         "r",
                                         "r",
                                         "r",
                                         "r",
                                         "r",
                                         "S[table-format = <0.3]"
                                 ),
                                 caption = thecaption,
                                 note = paste(
                                         "(ref:ast)(ref:ast)(ref:ast)(ref:italp) < .001, 
                                        (ref:ast)(ref:ast)(ref:italp) < .01, 
                                        (ref:ast)(ref:italp) < .05, (ref:cross)(ref:italp) <.10",
                                         sep = " "
                                 ),
                                 placement = "h",
                                 longtable = TRUE,
                                 escape = T
                                 #col_spanners = list(c(4,5))
                                 #format.args = list(margin = 2)
                         )
                 )
                 
         }
 
 

# Fuzzy Merge -------------------------------------------------------------

# Take two datasets with imperfectly matching 
 
my.fuzzy.merge <- function(dataset1, dataset2, var1, var2){
        library("RecordLinkage")
        ClosestMatch = function(string, stringVector){
                distance = levenshteinSim(string, stringVector);
                stringVector[distance == max(distance)]
        }
        
        for(i in 1:length(dataset2[[var2]])) {
                Matches <- ClosestMatch(dataset2[[var2]][i], levels(dataset1[[var1]]))
                dataset2[["name"]][i] <- Matches
        }
        merge(dataset1, dataset2, by.x = var1, by.y = "name")
}
 
